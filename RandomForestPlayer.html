<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Random Forest Inference</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2rem; background: #fafafa; }
        .section { margin-bottom: 2rem; border-bottom: 1px solid #ccc; padding-bottom: 1rem; background: #fff; padding: 1rem; border-radius: 8px; }
        label { display: block; margin-top: 0.5rem; }
        input, select, textarea, button { margin: 0.5rem 0; }
        button { padding: 8px 16px; cursor: pointer; background: #5a5a5a; color: white; border: none; border-radius: 0; }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .results { background-color: #f5f5f5; padding: 1rem; margin: 1rem 0; border-radius: 5px; }
        textarea { width: 100%; height: 5rem; font-family: monospace; resize: vertical; }
        .metric { font-weight: bold; }
        .inline-group { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; }
    </style>
</head>
<body>
    <h1>Random Forest Inference</h1>
    <div class="section">
        <h2>Load Trained Model</h2>
        <input type="file" id="modelFile" accept=".json">
        <button onclick="loadModel()">Load Model</button>
        <span id="modelStatus"></span>
    </div>
    <div class="section">
        <h2>Input Vector</h2>
        <label>Input (comma separated values): <input type="text" id="predictInput"></label>
        <button onclick="predictInput()">Predict</button>
    </div>
    <div class="section">
        <h2>Batch Prediction (CSV)</h2>
        <label>Paste CSV (one vector per line):</label>
        <textarea id="batchCSV"></textarea>
        <button onclick="predictBatch()">Predict Batch</button>
    </div>
    <div class="section">
        <h2>Forest Architecture</h2>
        <div id="forestViz"></div>
    </div>
    <div class="section">
        <h2>Output</h2>
        <div id="predictOutput" class="results"></div>
    </div>
<script>
// --- Minimal RandomForest for inference only ---
// Compatible with Pascal Forest.pas and FacadeForest.pas JSON format
class RandomForest {
    constructor() {
        this.numTrees = 0;
        this.maxDepth = 0;
        this.minSamplesLeaf = 1;
        this.minSamplesSplit = 2;
        this.maxFeatures = 0;
        this.numFeatures = 0;
        this.numSamples = 0;
        this.taskType = "classification";
        this.criterion = "gini";
        this.randomSeed = 42;
        this.trees = [];
        this.featureImportances = [];
    }
    
    static fromJSON(json) {
        const obj = typeof json === "string" ? JSON.parse(json) : json;
        const rf = new RandomForest();
        
        // Use snake_case field names from Pascal JSON format
        rf.numTrees = obj.num_trees || obj.numTrees || 0;
        rf.maxDepth = obj.max_depth || obj.maxDepth || 10;
        rf.minSamplesLeaf = obj.min_samples_leaf || obj.minSamplesLeaf || 1;
        rf.minSamplesSplit = obj.min_samples_split || obj.minSamplesSplit || 2;
        rf.maxFeatures = obj.max_features || obj.maxFeatures || 0;
        rf.numFeatures = obj.num_features || obj.numFeatures || 0;
        rf.numSamples = obj.num_samples || obj.numSamples || 0;
        rf.taskType = obj.task_type || obj.taskType || 'classification';
        rf.criterion = obj.criterion || 'gini';
        rf.randomSeed = obj.random_seed || obj.randomSeed || 42;
        
        // Load feature importances if present
        if (obj.feature_importances && Array.isArray(obj.feature_importances)) {
            rf.featureImportances = obj.feature_importances.slice();
        }
        
        // Load trees - Pascal stores root nodes directly in the trees array
        if (obj.trees && Array.isArray(obj.trees)) {
            rf.trees = [];
            for (let i = 0; i < obj.trees.length; i++) {
                const treeData = obj.trees[i];
                if (treeData !== null) {
                    // Pascal format: trees[i] is the root node directly
                    // JS format might wrap it: trees[i] = {root: node, oobMask: []}
                    if (treeData.isLeaf !== undefined || treeData.featureIndex !== undefined) {
                        // Direct root node (Pascal format)
                        rf.trees.push({ root: treeData, oobMask: [] });
                    } else if (treeData.root !== undefined) {
                        // Wrapped format (JS format)
                        rf.trees.push({ root: treeData.root, oobMask: treeData.oobMask || [] });
                    } else {
                        rf.trees.push({ root: null, oobMask: [] });
                    }
                } else {
                    rf.trees.push({ root: null, oobMask: [] });
                }
            }
        }
        
        return rf;
    }
    
    toJSON() {
        // Export in Pascal-compatible format (snake_case)
        const payload = {
            num_trees: this.numTrees,
            max_depth: this.maxDepth,
            min_samples_leaf: this.minSamplesLeaf,
            min_samples_split: this.minSamplesSplit,
            max_features: this.maxFeatures,
            num_features: this.numFeatures,
            num_samples: this.numSamples,
            task_type: this.taskType,
            criterion: this.criterion,
            random_seed: this.randomSeed,
            trees: this.trees.map(tree => tree ? tree.root : null)
        };
        
        if (this.featureImportances && this.featureImportances.length > 0) {
            const hasImportances = this.featureImportances.some(x => x !== 0);
            if (hasImportances) {
                payload.feature_importances = this.featureImportances.slice(0, this.numFeatures);
            }
        }
        
        return JSON.stringify(payload);
    }
    
    predict(sample) {
        // Filter out null/untrained trees
        const trainedTrees = this.trees.filter(t => t && t.root);
        if (trainedTrees.length === 0) {
            throw new Error("No trained trees available.");
        }
        
        if (this.taskType === "regression") {
            let preds = trainedTrees.map(tree => this.predictTree(tree.root, sample));
            return preds.reduce((a, b) => a + b, 0) / preds.length;
        } else {
            let votes = {};
            trainedTrees.forEach(tree => {
                let label = Math.round(this.predictTree(tree.root, sample));
                votes[label] = (votes[label] || 0) + 1;
            });
            return Number(Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b));
        }
    }
    
    predictTree(node, sample) {
        if (!node) return 0;
        if (node.isLeaf === true) return node.prediction || 0;
        if (node.featureIndex === undefined || node.threshold === undefined) return 0;
        if (sample[node.featureIndex] <= node.threshold)
            return this.predictTree(node.left, sample);
        else
            return this.predictTree(node.right, sample);
    }
    
    predictBatch(samples) {
        return samples.map(sample => this.predict(sample));
    }
    
    getNumFeatures() { 
        return this.numFeatures || 0;
    }
    
    getNumTrees() {
        return this.trees.filter(t => t && t.root).length;
    }
}

// ---- Forest Visualization ----
function visualizeForest(forest, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const numTrees = forest.numTrees || 0;
    const numFeatures = forest.numFeatures || forest.getNumFeatures() || 0;
    const trainedTrees = forest.trees ? forest.trees.filter(t => t && t.root).length : 0;
    const taskType = forest.taskType || 'classification';
    const maxDepth = forest.maxDepth || 10;
    
    const spacing = 60;
    const padding = 20;
    const legendSpace = 120;
    const treeDisplayCount = Math.min(numTrees, 15);
    const totalWidth = Math.max(500, legendSpace + padding * 2 + 120 + treeDisplayCount * spacing + 120);
    const totalHeight = 200;
    
    const svgContainer = document.createElement('div');
    svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', totalHeight);
    svg.setAttribute('style', 'display: block;');
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <linearGradient id="inputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#4285f4;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#1967d2;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="treeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#34a853;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#188038;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="treeUntrainedGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#9e9e9e;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#616161;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="outputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
        </linearGradient>
    `;
    svg.appendChild(defs);
    
    const cy = totalHeight / 2;
    let xPos = padding + legendSpace;
    
    // Draw Input Features box
    drawForestBox(svg, xPos, cy, 'Input', `${numFeatures} feat`, 'url(#inputGrad)', '#1967d2');
    xPos += 100;
    
    // Draw arrows from input to trees
    drawLine(svg, xPos - 40, cy, xPos + 10, cy - 30);
    drawLine(svg, xPos - 40, cy, xPos + 10, cy);
    drawLine(svg, xPos - 40, cy, xPos + 10, cy + 30);
    xPos += 20;
    
    // Draw trees
    for (let i = 0; i < treeDisplayCount; i++) {
        const isTrained = i < trainedTrees;
        const treeY = cy + (i % 3 - 1) * 35;
        drawTreeIcon(svg, xPos, treeY, i + 1, isTrained);
        xPos += spacing;
    }
    
    // If more trees than displayed
    if (numTrees > treeDisplayCount) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', xPos - 30);
        text.setAttribute('y', cy + 5);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '14');
        text.setAttribute('fill', '#666');
        text.textContent = `+${numTrees - treeDisplayCount}`;
        svg.appendChild(text);
        xPos += 30;
    }
    
    // Draw arrows from trees to output
    drawLine(svg, xPos - 20, cy - 30, xPos + 30, cy);
    drawLine(svg, xPos - 20, cy, xPos + 30, cy);
    drawLine(svg, xPos - 20, cy + 30, xPos + 30, cy);
    xPos += 40;
    
    // Draw Output box
    const outputLabel = taskType === 'classification' ? 'Vote' : 'Mean';
    drawForestBox(svg, xPos, cy, 'Output', outputLabel, 'url(#outputGrad)', '#f57d00');
    
    // Draw legend
    drawForestLegend(svg, padding + 5, cy - 50, trainedTrees, numTrees);
    
    svgContainer.appendChild(svg);
    container.innerHTML = '';
    container.appendChild(svgContainer);
}

function drawForestBox(svg, x, cy, label1, label2, fill, stroke) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 30);
    box.setAttribute('y', cy - 35);
    box.setAttribute('width', 60);
    box.setAttribute('height', 70);
    box.setAttribute('fill', fill);
    box.setAttribute('stroke', stroke);
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 8);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = label1;
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '9');
    text2.setAttribute('fill', 'white');
    text2.textContent = label2;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawTreeIcon(svg, x, cy, treeNum, isTrained) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const fill = isTrained ? 'url(#treeGrad)' : 'url(#treeUntrainedGrad)';
    const stroke = isTrained ? '#188038' : '#616161';
    
    const trunk = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    trunk.setAttribute('x', x - 4);
    trunk.setAttribute('y', cy + 8);
    trunk.setAttribute('width', 8);
    trunk.setAttribute('height', 12);
    trunk.setAttribute('fill', '#8d6e63');
    trunk.setAttribute('rx', 1);
    g.appendChild(trunk);
    
    const crown = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    crown.setAttribute('points', `${x},${cy - 22} ${x - 18},${cy + 10} ${x + 18},${cy + 10}`);
    crown.setAttribute('fill', fill);
    crown.setAttribute('stroke', stroke);
    crown.setAttribute('stroke-width', 1);
    g.appendChild(crown);
    
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', cy + 1);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-size', '8');
    text.setAttribute('font-weight', 'bold');
    text.setAttribute('fill', 'white');
    text.textContent = treeNum;
    g.appendChild(text);
    
    svg.appendChild(g);
}

function drawLine(svg, x1, y1, x2, y2) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', '#999');
    line.setAttribute('stroke-width', 1);
    svg.appendChild(line);
}

function drawForestLegend(svg, x, y, trainedTrees, totalTrees) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const box1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box1.setAttribute('x', x);
    box1.setAttribute('y', y);
    box1.setAttribute('width', 12);
    box1.setAttribute('height', 12);
    box1.setAttribute('fill', 'url(#treeGrad)');
    box1.setAttribute('stroke', '#188038');
    box1.setAttribute('rx', 2);
    g.appendChild(box1);
    
    const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label1.setAttribute('x', x + 16);
    label1.setAttribute('y', y + 10);
    label1.setAttribute('font-size', '9');
    label1.setAttribute('fill', '#333');
    label1.textContent = `Trained (${trainedTrees})`;
    g.appendChild(label1);
    
    const box2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box2.setAttribute('x', x);
    box2.setAttribute('y', y + 18);
    box2.setAttribute('width', 12);
    box2.setAttribute('height', 12);
    box2.setAttribute('fill', 'url(#treeUntrainedGrad)');
    box2.setAttribute('stroke', '#616161');
    box2.setAttribute('rx', 2);
    g.appendChild(box2);
    
    const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label2.setAttribute('x', x + 16);
    label2.setAttribute('y', y + 28);
    label2.setAttribute('font-size', '9');
    label2.setAttribute('fill', '#333');
    label2.textContent = `Untrained`;
    g.appendChild(label2);
    
    const label3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label3.setAttribute('x', x);
    label3.setAttribute('y', y + 50);
    label3.setAttribute('font-size', '9');
    label3.setAttribute('fill', '#666');
    label3.textContent = `Total: ${totalTrees}`;
    g.appendChild(label3);
    
    svg.appendChild(g);
}

// ====== UI logic for inference ======
let rfModel = null, modelConfig = null;

function loadModel() {
    let fileInput = document.getElementById('modelFile');
    let status = document.getElementById('modelStatus');
    if (!fileInput.files.length) {
        status.textContent = 'No file selected.'; return;
    }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            rfModel = RandomForest.fromJSON(e.target.result);
            modelConfig = rfModel;
            const trainedTrees = rfModel.getNumTrees();
            status.textContent = "âœ“ Model loaded. Trees: " + rfModel.numTrees 
                + " (" + trainedTrees + " trained)"
                + ", Features: " + rfModel.getNumFeatures()
                + ", Samples: " + rfModel.numSamples
                + ", Type: " + rfModel.taskType
                + ", Criterion: " + rfModel.criterion;
            visualizeForest(rfModel, 'forestViz');
        } catch (err) {
            status.textContent = "Error loading model: " + err;
        }
    };
    reader.readAsText(fileInput.files[0]);
}

function predictInput() {
    let outDiv = document.getElementById('predictOutput');
    if (!rfModel) { outDiv.textContent = "Model not loaded."; return; }
    let val = document.getElementById("predictInput").value.trim();
    let arr = val.split(',').map(Number);
    const nFeat = rfModel.getNumFeatures();
    if (arr.length !== nFeat) {
        outDiv.textContent = 'Error: Input vector size mismatch! Model expects '+nFeat;
        return;
    }
    try {
        let pred = rfModel.predict(arr);
        outDiv.textContent = 'Prediction: '+pred;
    } catch (err) {
        outDiv.textContent = "Prediction error: "+err;
    }
}

function predictBatch() {
    let outDiv = document.getElementById('predictOutput');
    if (!rfModel) { outDiv.textContent = "Model not loaded."; return; }
    let txt = document.getElementById('batchCSV').value.trim();
    if (!txt) { outDiv.textContent = "No CSV input."; return; }
    let rows = txt.split('\n').map(r=>r.trim()).filter(Boolean);
    let arrs = rows.map(row=>row.split(',').map(Number));
    const nFeat = rfModel.getNumFeatures();
    if (arrs.some(a => a.length !== nFeat || a.some(isNaN))) {
        outDiv.textContent = 'Error: All input vectors must have '+nFeat+" numeric values.";
        return;
    }
    try {
        let preds = rfModel.predictBatch(arrs);
        outDiv.textContent = "Predictions:\n" + JSON.stringify(preds, null, 2);
    } catch (err) {
        outDiv.textContent = "Prediction error: "+err;
    }
}
</script>
</body>
</html>
