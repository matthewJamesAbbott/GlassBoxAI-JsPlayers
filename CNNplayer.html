<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CNN Player</title>
    <style>
        body { font-family: Arial,sans-serif; margin:2rem; background:#fafafa; }
        .section { margin-bottom:2rem; }
        label, input, textarea, button { margin:0.5rem 0; }
        textarea { width: 100%; height: 7rem; font-family: monospace; resize: vertical; }
        .results { background: #f5f5f5; padding: 1rem; border-radius: 5px; }
        button { 
            padding: 0.5rem 1rem; background: #5a5a5a; color: white; border-radius: 0;
            border: none; cursor: pointer; font-size: 0.95rem;
        }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #94a3b8; cursor: not-allowed;}
        canvas { border: 1px solid #ccc; background: #fff; margin-bottom:1rem;}
        #modelStatus { 
            display: inline-block; 
            padding: 0.5rem 1rem; 
            border-radius: 4px; 
            background: #e8f5e9; 
            color: #2e7d32; 
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>CNN Player</h1>

    <!-- Network Architecture Visualization -->
    <div class="section">
        <h2>Network Architecture</h2>
        <div id="networkVisualization"></div>
    </div>

    <div class="section">
        <h2>Load Trained Model</h2>
        <input type="file" id="modelFile" accept=".json" onchange="loadModel()" style="display:none">
        <button onclick="document.getElementById('modelFile').click()">Load Model (JSON)</button>
        <span id="modelStatus" style="margin-left: 1rem; font-weight: bold;"></span>
    </div>

    <div class="section">
        <h2>Input Image</h2>
        <div>
            <label>Upload Image:
                <input type="file" id="imageUpload" accept="image/*" onchange="handleImageUpload(event)">
            </label>
        </div>
        <div>
            <label>Or Paste CSV (channels,height,width, comma separated):</label>
            <textarea id="imageCSV" placeholder="Ex: 0.0,0.1,..."></textarea>
            <button onclick="loadImageCSV()">Load CSV as Image</button>
        </div>
        <div>
            <canvas id="inputCanvas" width="140" height="140"></canvas>
        </div>
        <div id="imageStatus"></div>
    </div>

    <div class="section">
        <button onclick="predictSingleImage()">Predict Image</button>
    </div>

    <div class="section">
        <h2>Output</h2>
        <div id="predictionResult" class="results"></div>
    </div>

<script>
/**
 * Network Visualizer - SVG-based CNN architecture visualization
 * Works with index.html, facaded_cnn.html, and cnn_player.html
 */

function visualizeNetworkArchitecture(cnn, containerId) {
    if (!cnn) return;
    
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Calculate dimensions - compact version
    const spacing = 85;
    const padding = 20;
    const legendSpace = 80; // Space for legend on the left
    const neuronRadius = 3;
    
    const numConvLayers = cnn.convLayers?.length || 0;
    const numPoolLayers = cnn.poolLayers?.length || 0;
    const numFcLayers = cnn.fcLayers?.length || 0;
    const totalLayers = 2 + numConvLayers + numPoolLayers + numFcLayers; // input + output + others
    
    const totalWidth = totalLayers * spacing + padding * 2 + legendSpace;
    const totalHeight = 200;
    
    // Create SVG with scrollable container
    const svgContainer = document.createElement('div');
    svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', totalHeight);
    svg.setAttribute('style', 'display: block;');
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <linearGradient id="convGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#4285f4;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#1967d2;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="poolGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#34a853;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#188038;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="fcGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#ea4335;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#c5221f;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="outGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
        </linearGradient>
    `;
    svg.appendChild(defs);
    
    let xPos = padding + legendSpace;
    let layerIndex = 0;
    
    // Draw input layer
    const inputNeurons = cnn.channels || 1;
    drawInputLayer(svg, xPos, totalHeight / 2, inputNeurons, cnn.inputWidth, cnn.inputHeight);
    xPos += spacing;
    
    // Draw conv and pool layers
    if (cnn.convLayers && cnn.convLayers.length > 0) {
        for (let i = 0; i < cnn.convLayers.length; i++) {
            const filters = cnn.convFilters?.[i] || 1;
            drawConvLayer(svg, xPos, totalHeight / 2, filters, i + 1, cnn.kernelSizes?.[i] || 3);
            xPos += spacing;
            
            // Draw pool layer if exists
            if (cnn.poolLayers && i < cnn.poolLayers.length) {
                const poolSize = cnn.poolSizes?.[i] || 2;
                drawPoolLayer(svg, xPos, totalHeight / 2, poolSize, i + 1);
                xPos += spacing;
            }
        }
    }
    
    // Draw FC layers
    if (cnn.fcLayers && cnn.fcLayers.length > 0) {
        for (let i = 0; i < cnn.fcLayers.length; i++) {
            const neurons = cnn.fcSizes?.[i] || 128;
            drawFCLayer(svg, xPos, totalHeight / 2, neurons, i + 1);
            xPos += spacing;
        }
    }
    
    // Draw output layer
    const outputNeurons = cnn.outputSize || 10;
    drawOutputLayer(svg, xPos, totalHeight / 2, outputNeurons);
    
    // Draw legend vertically centered on the left
    drawLegend(svg, padding + 5, totalHeight / 2 - 30);
    
    // Add SVG to scrollable container
    svgContainer.innerHTML = '';
    svgContainer.appendChild(svg);
    
    // Replace container content
    container.innerHTML = '';
    container.appendChild(svgContainer);
}

function drawInputLayer(svg, x, cy, channels, width, height) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw box
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 25);
    box.setAttribute('y', cy - 35);
    box.setAttribute('width', 50);
    box.setAttribute('height', 70);
    box.setAttribute('fill', '#e8f5e9');
    box.setAttribute('stroke', '#2e7d32');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    // Draw text
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', '#1b5e20');
    text1.textContent = 'Input';
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 2);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '9');
    text2.setAttribute('fill', '#1b5e20');
    text2.textContent = `${width}×${height}`;
    g.appendChild(text2);
    
    const text3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text3.setAttribute('x', x);
    text3.setAttribute('y', cy + 15);
    text3.setAttribute('text-anchor', 'middle');
    text3.setAttribute('font-size', '9');
    text3.setAttribute('fill', '#1b5e20');
    text3.textContent = `ch:${channels}`;
    g.appendChild(text3);
    
    svg.appendChild(g);
}

function drawConvLayer(svg, x, cy, filters, layerNum, kernelSize) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw box
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 28);
    box.setAttribute('y', cy - 35);
    box.setAttribute('width', 56);
    box.setAttribute('height', 70);
    box.setAttribute('fill', 'url(#convGrad)');
    box.setAttribute('stroke', '#1967d2');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    // Draw text
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '9');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = `C${layerNum}`;
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 2);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '8');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${filters}f`;
    g.appendChild(text2);
    
    const text3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text3.setAttribute('x', x);
    text3.setAttribute('y', cy + 14);
    text3.setAttribute('text-anchor', 'middle');
    text3.setAttribute('font-size', '8');
    text3.setAttribute('fill', 'white');
    text3.textContent = `k${kernelSize}`;
    g.appendChild(text3);
    
    svg.appendChild(g);
}

function drawPoolLayer(svg, x, cy, poolSize, layerNum) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw box
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 23);
    box.setAttribute('y', cy - 30);
    box.setAttribute('width', 46);
    box.setAttribute('height', 60);
    box.setAttribute('fill', 'url(#poolGrad)');
    box.setAttribute('stroke', '#188038');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    // Draw text
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 12);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '9');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = 'Pool';
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '8');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${poolSize}×${poolSize}`;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawFCLayer(svg, x, cy, neurons, layerNum) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw box
    const boxHeight = 70;
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 25);
    box.setAttribute('y', cy - boxHeight / 2);
    box.setAttribute('width', 50);
    box.setAttribute('height', boxHeight);
    box.setAttribute('fill', 'url(#fcGrad)');
    box.setAttribute('stroke', '#c5221f');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    // Draw text
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '9');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = `FC${layerNum}`;
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '8');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${neurons}`;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawOutputLayer(svg, x, cy, neurons) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    // Draw box
    const boxHeight = 70;
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 28);
    box.setAttribute('y', cy - boxHeight / 2);
    box.setAttribute('width', 56);
    box.setAttribute('height', boxHeight);
    box.setAttribute('fill', 'url(#outGrad)');
    box.setAttribute('stroke', '#f57d00');
    box.setAttribute('stroke-width', 1.5);
    box.setAttribute('rx', 3);
    g.appendChild(box);
    
    // Draw text
    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x);
    text1.setAttribute('y', cy - 18);
    text1.setAttribute('text-anchor', 'middle');
    text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold');
    text1.setAttribute('fill', 'white');
    text1.textContent = 'Output';
    g.appendChild(text1);
    
    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x);
    text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle');
    text2.setAttribute('font-size', '8');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${neurons}c`;
    g.appendChild(text2);
    
    svg.appendChild(g);
}

function drawLegend(svg, x, y) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    
    const items = [
        { label: 'Conv', color: 'url(#convGrad)' },
        { label: 'Pool', color: 'url(#poolGrad)' },
        { label: 'FC', color: 'url(#fcGrad)' },
        { label: 'Out', color: 'url(#outGrad)' }
    ];
    
    let yOffset = y;
    items.forEach(item => {
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', x);
        box.setAttribute('y', yOffset);
        box.setAttribute('width', 10);
        box.setAttribute('height', 10);
        box.setAttribute('fill', item.color);
        box.setAttribute('stroke', '#666');
        box.setAttribute('stroke-width', 0.5);
        box.setAttribute('rx', 2);
        g.appendChild(box);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x + 14);
        text.setAttribute('y', yOffset + 8);
        text.setAttribute('font-size', '9');
        text.setAttribute('fill', '#333');
        text.textContent = item.label;
        g.appendChild(text);
        
        yOffset += 13;
    });
    
    svg.appendChild(g);
}

// *** Minimal CNN class for inference ***
class CNN {
    constructor(inputWidth, inputHeight, channels, convFilters, kernelSizes, poolSizes, fcSizes, outputSize) {
        this.inputWidth = inputWidth;
        this.inputHeight = inputHeight;
        this.channels = channels;
        this.convFilters = convFilters;
        this.kernelSizes = kernelSizes;
        this.poolSizes = poolSizes;
        this.fcSizes = fcSizes;
        this.outputSize = outputSize;
        this.initLayers();
    }
    initLayers() {
        this.convLayers = [];
        this.poolLayers = [];
        let currWidth = this.inputWidth, currHeight = this.inputHeight, currChannels = this.channels;
        for (let i = 0; i < this.convFilters.length; i++) {
            let kernel = this.kernelSizes[i];
            let filters = this.convFilters[i];
            let padding = Math.floor(kernel / 2);
            this.convLayers.push(this.initConvLayer(filters, currChannels, kernel, padding));
            currWidth = Math.floor((currWidth - kernel + 2 * padding) / 1 + 1);
            currHeight = Math.floor((currHeight - kernel + 2 * padding) / 1 + 1);
            currChannels = filters;
            if (i < this.poolSizes.length) {
                let pool = this.poolSizes[i];
                this.poolLayers.push(this.initPoolLayer(pool));
                currWidth = Math.floor(currWidth / pool); currHeight = Math.floor(currHeight / pool);
            }
        }
        this.flattenedSize = currWidth * currHeight * currChannels;
        this.fcLayers = [];
        let numInputs = this.flattenedSize;
        for (let sz of this.fcSizes) {
            this.fcLayers.push(this.initFCLayer(sz, numInputs)); numInputs = sz;
        }
        this.outputLayer = this.initFCLayer(this.outputSize, numInputs);
    }
    initConvLayer(numFilters, inChannels, kernel, padding) {
        let filters = [];
        for (let i = 0; i < numFilters; i++) {
            let w = [];
            for (let c = 0; c < inChannels; c++) {
                let k = [];
                for (let h = 0; h < kernel; h++) {
                    let row = [];
                    for (let wIdx = 0; wIdx < kernel; wIdx++) row.push(0);
                    k.push(row);
                }
                w.push(k);
            }
            filters.push({ weights: w, bias: 0 });
        }
        return { filters, stride: 1, padding, kernel, inChannels };
    }
    initPoolLayer(poolSize) { return { poolSize }; }
    initFCLayer(numNeurons, numInputs) {
        let neurons = [];
        for (let i = 0; i < numNeurons; i++) neurons.push({ weights: new Array(numInputs).fill(0), bias: 0, output: 0 });
        return { neurons };
    }
    relu(x) { return Math.max(0, x); }
    softmax(arr) {
        let max = Math.max(...arr), exps = arr.map(a=>Math.exp(a-max)), sum = exps.reduce((a,b)=>a+b,0);
        return exps.map(e=>e/sum);
    }
    pad3D(input, padding) {
        if (padding === 0) return input;
        let channels = input.length, h = input[0].length, w = input[0][0].length;
        let padded = [];
        for (let c = 0; c < channels; c++) {
            let chan = [];
            for (let i = 0; i < h + 2 * padding; i++) {
                let row = [];
                for (let j = 0; j < w + 2 * padding; j++) {
                    let srcI = i - padding, srcJ = j - padding;
                    row.push((srcI >= 0 && srcI < h && srcJ >= 0 && srcJ < w) ? input[c][srcI][srcJ] : 0);
                }
                chan.push(row);
            }
            padded.push(chan);
        }
        return padded;
    }
    convForward(layer, input, inWidth, inHeight) {
        let paddedInput = this.pad3D(input, layer.padding);
        let kernel = layer.kernel, outWidth = Math.floor((inWidth + 2 * layer.padding - kernel) / 1 + 1);
        let outHeight = Math.floor((inHeight + 2 * layer.padding - kernel) / 1 + 1);
        let inChannels = input.length;
        let outputMaps = [];
        for (let f = 0; f < layer.filters.length; f++) {
            let map = [];
            for (let h = 0; h < outHeight; h++) {
                let row = [];
                for (let w = 0; w < outWidth; w++) {
                    let sum = layer.filters[f].bias;
                    for (let c = 0; c < inChannels; c++)
                        for (let kh = 0; kh < kernel; kh++)
                            for (let kw = 0; kw < kernel; kw++)
                                sum += paddedInput[c][h+kh][w+kw] * layer.filters[f].weights[c][kh][kw];
                    row.push(this.relu(sum));
                }
                map.push(row);
            }
            outputMaps.push(map);
        }
        return outputMaps;
    }
    poolForward(layer, input, inWidth, inHeight) {
        let outputMaps = [];
        let outWidth = Math.floor(inWidth / layer.poolSize), outHeight = Math.floor(inHeight / layer.poolSize);
        for (let c = 0; c < input.length; c++) {
            let map = [];
            for (let h = 0; h < outHeight; h++) {
                let row = [];
                for (let w = 0; w < outWidth; w++) {
                    let maxVal = -Infinity;
                    for (let ph = 0; ph < layer.poolSize; ph++)
                        for (let pw = 0; pw < layer.poolSize; pw++)
                            maxVal = Math.max(maxVal, input[c][h * layer.poolSize + ph][w * layer.poolSize + pw]);
                    row.push(maxVal);
                }
                map.push(row);
            }
            outputMaps.push(map);
        }
        return outputMaps;
    }
    flattenFeatures(input) {
        let arr = [];
        for (let c = 0; c < input.length; c++)
            for (let h = 0; h < input[c].length; h++)
                for (let w = 0; w < input[c][h].length; w++)
                    arr.push(input[c][h][w]);
        this.lastConvShape = { channels: input.length, height: input[0].length, width: input[0][0].length };
        return arr;
    }
    fcForward(layer, input) {
        let outputs = [];
        for (let n of layer.neurons) {
            let sum = n.bias;
            for (let j = 0; j < input.length; j++) sum += input[j] * n.weights[j];
            n.output = this.relu(sum);
            outputs.push(n.output);
        }
        return outputs;
    }
    forward(imageObj) {
        let { data, width, height } = imageObj;
        let currentOutput = data;
        let currWidth = width, currHeight = height;
        for (let i = 0; i < this.convLayers.length; i++) {
            currentOutput = this.convForward(this.convLayers[i], currentOutput, currWidth, currHeight);
            currWidth = currentOutput[0][0].length; currHeight = currentOutput[0].length;
            if (i < this.poolLayers.length) {
                currentOutput = this.poolForward(this.poolLayers[i], currentOutput, currWidth, currHeight);
                currWidth = currentOutput[0][0].length; currHeight = currentOutput[0].length;
            }
        }
        let flat = this.flattenFeatures(currentOutput);
        let layerInput = flat;
        for (let fcl of this.fcLayers)
            layerInput = this.fcForward(fcl, layerInput);
        let logits = [];
        for (let n of this.outputLayer.neurons) {
            let sum = n.bias;
            for (let j = 0; j < layerInput.length; j++)
                sum += layerInput[j] * n.weights[j];
            logits.push(sum);
        }
        let probs = this.softmax(logits);
        return probs;
    }
    predictImage(imageObj) { return this.forward(imageObj); }
    static fromJSON(json) {
        // Handle both formats: direct properties and nested config
        let cfg = json.config || json;
        
        // Support both camelCase and snake_case field names
        let inputWidth = cfg.inputWidth || cfg.input_width || 28;
        let inputHeight = cfg.inputHeight || cfg.input_height || 28;
        let channels = cfg.channels || cfg.input_channels || 1;
        let convFilters = cfg.convFilters || cfg.conv_filters || [16];
        let kernelSizes = cfg.kernelSizes || cfg.kernel_sizes || [3];
        let poolSizes = cfg.poolSizes || cfg.pool_sizes || [2];
        let fcSizes = cfg.fcSizes || cfg.fcLayerSizes || cfg.fc_layer_sizes || [128];
        let outputSize = cfg.outputSize || cfg.output_size || 10;
        
        // Ensure arrays
        if (!Array.isArray(convFilters)) convFilters = [convFilters];
        if (!Array.isArray(kernelSizes)) kernelSizes = [kernelSizes];
        if (!Array.isArray(poolSizes)) poolSizes = [poolSizes];
        if (!Array.isArray(fcSizes)) fcSizes = [fcSizes];
        
        let net = new CNN(inputWidth, inputHeight, channels, convFilters, kernelSizes, poolSizes, fcSizes, outputSize);
        
        // Load conv layers - handle both conv_layers and convLayers
        let convLayers = json.conv_layers || json.convLayers || [];
        if (convLayers.length > 0) {
            for (let i = 0; i < convLayers.length && i < net.convLayers.length; i++) {
                let jl = convLayers[i];
                if (jl.filters && Array.isArray(jl.filters)) {
                    for (let f = 0; f < jl.filters.length && f < net.convLayers[i].filters.length; f++) {
                        let jsonFilter = jl.filters[f];
                        if (jsonFilter.weights && Array.isArray(jsonFilter.weights)) {
                            let weights = jsonFilter.weights;
                            // Handle Pascal format: weights might be [1][channels][height][width]
                            if (weights.length === 1 && Array.isArray(weights[0])) {
                                net.convLayers[i].filters[f].weights = JSON.parse(JSON.stringify(weights[0]));
                            } else {
                                net.convLayers[i].filters[f].weights = JSON.parse(JSON.stringify(weights));
                            }
                        }
                        if (typeof jsonFilter.bias === 'number') {
                            net.convLayers[i].filters[f].bias = jsonFilter.bias;
                        }
                    }
                }
            }
        }
        
        // Load FC layers
        let fcLayers = json.fc_layers || json.fcLayers || [];
        if (fcLayers.length > 0) {
            for (let i = 0; i < fcLayers.length && i < net.fcLayers.length; i++) {
                let jl = fcLayers[i];
                if (jl.neurons && Array.isArray(jl.neurons)) {
                    for (let n = 0; n < jl.neurons.length && n < net.fcLayers[i].neurons.length; n++) {
                        Object.assign(net.fcLayers[i].neurons[n], jl.neurons[n]);
                    }
                }
            }
        }
        
        // Load output layer
        let outputLayer = json.output_layer || json.outputLayer || { neurons: [] };
        if (outputLayer.neurons && Array.isArray(outputLayer.neurons)) {
            for (let n = 0; n < outputLayer.neurons.length && n < net.outputLayer.neurons.length; n++) {
                Object.assign(net.outputLayer.neurons[n], outputLayer.neurons[n]);
            }
        }
        
        return net;
    }
}

// ====== Inference UI logic ======
let cnnModel = null, modelConfig = null, lastImageObj = null;

function loadModel() {
     console.log('loadModel() called');
     let fileInput = document.getElementById('modelFile');
     let status = document.getElementById('modelStatus');
     if (!fileInput.files.length) {
         console.log('loadModel: No file selected');
         status.textContent = 'No file selected.'; 
         return;
     }
     const file = fileInput.files[0];
     console.log('Loading file:', file.name, 'size:', file.size);
     status.textContent = 'Loading JSON file: ' + file.name + '...';
     
     const reader = new FileReader();
     reader.onload = function(e) {
         try {
             console.log('File read, content size:', e.target.result.length);
             const parsed = JSON.parse(e.target.result);
             console.log('JSON parsed successfully');
             cnnModel = CNN.fromJSON(parsed);
             console.log('Model created from JSON');
             
             // Extract config from either nested config or root level (support both formats)
             let cfg = parsed.config || parsed;
             modelConfig = {
                 inputWidth: cfg.inputWidth || cfg.input_width || 28,
                 inputHeight: cfg.inputHeight || cfg.input_height || 28,
                 channels: cfg.channels || cfg.input_channels || 1,
                 outputSize: cfg.outputSize || cfg.output_size || 10
             };
             
             status.textContent = "✓ Model loaded from " + file.name + ": "
                 + "Size:" + modelConfig.inputWidth + "x" + modelConfig.inputHeight
                 + ", Channels:" + modelConfig.channels
                 + ", Classes:" + modelConfig.outputSize 
                 + " (File: " + e.target.result.length + " bytes)";
             visualizeNetworkArchitecture(cnnModel, 'networkVisualization');
             console.log('Model loaded successfully');
             } catch (err) {
             console.error('Error loading model:', err);
             status.textContent = "✗ Error loading model: " + err.message;
         }
     };
     reader.readAsText(file);
}

function handleImageUpload(event) {
    let files = event.target.files;
    if (!files.length) return;
    let file = files[0];
    let reader = new FileReader();
    reader.onload = function(e) {
        let img = new window.Image();
        img.onload = function() {
            let w = modelConfig?.inputWidth || 28, h = modelConfig?.inputHeight || 28, ch = modelConfig?.channels || 1;
            let canvas = document.getElementById("inputCanvas");
            canvas.width = w; canvas.height = h;
            let ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, w, h);
            let imgData = ctx.getImageData(0, 0, w, h);
            let data = [];
            for (let c = 0; c < ch; c++) {
                let chan = [];
                for (let i = 0; i < h; i++) {
                    let row = [];
                    for (let j = 0; j < w; j++) {
                        let idx = (i * w + j) * 4;
                        if (ch === 1)
                            row.push(imgData.data[idx] / 255);
                        else
                            row.push(imgData.data[idx + c] / 255);
                    }
                    chan.push(row);
                }
                data.push(chan);
            }
            lastImageObj = { data, width: w, height: h, channels: ch };
            document.getElementById("imageStatus").textContent = "Image loaded (" + w + "x" + h + ", ch: " + ch + ")";
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function loadImageCSV() {
    let txt = document.getElementById("imageCSV").value.trim();
    if (!txt) { document.getElementById("imageStatus").textContent = "Enter some CSV values."; return; }
    if (!modelConfig) { document.getElementById("imageStatus").textContent = "Load model first."; return; }
    let w = modelConfig.inputWidth, h = modelConfig.inputHeight, ch = modelConfig.channels;
    let arr = txt.split(",").map(Number);
    if (arr.length !== w * h * ch) {
        document.getElementById("imageStatus").textContent = "CSV length (" + arr.length + ") doesn't match expected " + (w * h * ch);
        return;
    }
    let data = [];
    let idx = 0;
    for (let c = 0; c < ch; c++) {
        let chan = [];
        for (let i = 0; i < h; i++) {
            let row = [];
            for (let j = 0; j < w; j++)
                row.push(arr[idx++]);
            chan.push(row);
        }
        data.push(chan);
    }
    lastImageObj = { data, width: w, height: h, channels: ch };
    let canvas = document.getElementById("inputCanvas");
    canvas.width = w; canvas.height = h;
    let ctx = canvas.getContext("2d");
    for (let i = 0; i < h; i++) {
        for (let j = 0; j < w; j++) {
            let v = ch === 1 ? data[0][i][j] : ((data[0][i][j] + data[1][i][j] + (data[2]?.[i][j]||0))/ch);
            let col = Math.round(v*255);
            ctx.fillStyle = "rgb("+col+","+col+","+col+")";
            ctx.fillRect(j, i, 1, 1);
        }
    }
    document.getElementById("imageStatus").textContent = "CSV image loaded (" + w + "x" + h + ", ch: " + ch + ")";
}

function predictSingleImage() {
    let pDiv = document.getElementById('predictionResult');
    if (!cnnModel || !modelConfig) { pDiv.textContent = "No model loaded."; return; }
    if (!lastImageObj) { pDiv.textContent = "No image loaded."; return; }
    try {
        const out = cnnModel.predictImage(lastImageObj);
        pDiv.textContent = "Predicted probabilities: " + JSON.stringify(out, null, 2);
    } catch (err) {
        pDiv.textContent = "Inference error: " + err;
    }
}
</script>
</body>
</html>
