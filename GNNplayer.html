<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GNN Inference Only</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 2rem; background: #fafafa; color: #1e293b;}
        .section { margin-bottom: 2rem;}
        label, input, textarea, button { margin: 0.5rem 0;}
        textarea { width: 100%; height: 6rem; font-family: monospace; resize: vertical; }
        .results { background: #f5f5f5; padding: 1rem; border-radius: 5px; }
        button { 
            padding: 8px 16px; 
            background: #5a5a5a;
            color: white; 
            border-radius: 0; border: none; cursor: pointer; font-size: 0.95rem;
        }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #ccc; cursor: not-allowed;}
    </style>
</head>
<body>
    <h1>GNN Inference</h1>

    <div class="section" id="networkVizSection" style="display:none;">
        <h2>Network Architecture</h2>
        <div id="networkVisualization"></div>
    </div>

    <div class="section">
        <h2>Load Trained Model</h2>
        <input type="file" id="modelFile" accept=".json">
        <button onclick="loadModel()">Load Model</button>
        <span id="modelStatus"></span>
    </div>

    <div class="section">
        <h2>Node Features</h2>
        <label>Paste CSV features (each row is node, values comma separated):</label>
        <textarea id="nodeFeatures"></textarea>
    </div>

    <div class="section">
        <h2>Edges</h2>
        <label>Paste Edge List (source,target per line):</label>
        <textarea id="edgeList"></textarea>
    </div>
    
    <div class="section">
        <button onclick="runInference()">Run Inference</button>
    </div>

    <div class="section">
        <h2>Output</h2>
        <div id="output" class="results"></div>
    </div>

<script>
class Edge {
    constructor(source, target) { this.source = source; this.target = target; }
    equals(other) { return this.source === other.source && this.target === other.target; }
    toKey() { return `${this.source}-${this.target}`; }
}

class Graph {
    constructor(numNodes) {
        this.numNodes = numNodes;
        this.nodeFeatures = Array(numNodes).fill(null).map(() => []);
        this.edges = [];
        this.adjacencyList = Array(numNodes).fill(null).map(() => []);
    }
    buildAdjacencyList(undirected = false, selfLoops = false) {
        this.adjacencyList = Array(this.numNodes).fill(null).map(() => []);
        for (const edge of this.edges) {
            this.adjacencyList[edge.source].push(edge.target);
            if (undirected && edge.source !== edge.target) {
                this.adjacencyList[edge.target].push(edge.source);
            }
        }
        if (selfLoops) {
            for (let i = 0; i < this.numNodes; i++) {
                if (!this.adjacencyList[i].includes(i)) {
                    this.adjacencyList[i].push(i);
                }
            }
        }
    }
}

const activations = {
    relu: { fn: x => Math.max(0, x) },
    leaky_relu: { fn: x => x > 0 ? x : 0.01 * x },
    tanh: { fn: x => Math.tanh(x) },
    sigmoid: { fn: x => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x)))) }
};

class DenseLayer {
    constructor(numOutputs, numInputs) {
        this.numOutputs = numOutputs;
        this.numInputs = numInputs;
        this.weights = Array(numOutputs).fill(null).map(() =>
            Array(numInputs).fill(0)
        );
        this.biases = Array(numOutputs).fill(0);
    }
    forward(input, activation) {
        let out = [];
        for (let i = 0; i < this.numOutputs; i++) {
            let sum = this.biases[i];
            for (let j = 0; j < this.numInputs; j++) {
                sum += this.weights[i][j] * input[j];
            }
            out[i] = activation.fn(sum);
        }
        return out;
    }
    setWeights(data) {
        this.weights = data.weights.map(w => w.slice());
        this.biases = data.biases.slice();
    }
}

class GraphNeuralNetwork {
    constructor(featureSize, hiddenSize, outputSize, numMPLayers) {
        this.featureSize = featureSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.numMPLayers = numMPLayers;
        this.activationType = 'relu';
        this.messageLayers = [];
        this.updateLayers = [];
        for (let i = 0; i < numMPLayers; i++) {
            const inputSize = i === 0 ? featureSize * 2 : hiddenSize * 2;
            this.messageLayers.push(new DenseLayer(hiddenSize, inputSize));
            this.updateLayers.push(new DenseLayer(hiddenSize, hiddenSize * 2));
        }
        this.readoutLayer = new DenseLayer(hiddenSize, hiddenSize);
        this.outputLayer = new DenseLayer(outputSize, hiddenSize);
    }
    get activation() { return activations[this.activationType]; }
    forward(graph) {
        const N = graph.numNodes, activation = this.activation;
        let currentEmbeddings = graph.nodeFeatures.map(f => f.slice());
        for (let layer = 0; layer < this.numMPLayers; layer++) {
            let newEmbeddings = [];
            for (let node = 0; node < N; node++) {
                const neighbors = graph.adjacencyList[node];
                let aggregatedMessage = Array(this.hiddenSize).fill(0);
                if (neighbors.length > 0) {
                    for (const neighbor of neighbors) {
                        const concat = currentEmbeddings[node].concat(currentEmbeddings[neighbor]);
                        const message = this.messageLayers[layer].forward(concat, activation);
                        for (let i = 0; i < this.hiddenSize; i++)
                            aggregatedMessage[i] += message[i];
                    }
                    for (let i = 0; i < this.hiddenSize; i++)
                        aggregatedMessage[i] /= neighbors.length;
                }
                let updateInput;
                if (layer === 0) {
                    const paddedFeatures = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < Math.min(currentEmbeddings[node].length, this.hiddenSize); i++) {
                        paddedFeatures[i] = currentEmbeddings[node][i];
                    }
                    updateInput = paddedFeatures.concat(aggregatedMessage);
                } else {
                    updateInput = currentEmbeddings[node].concat(aggregatedMessage);
                }
                const newEmb = this.updateLayers[layer].forward(updateInput, activation);
                newEmbeddings.push(newEmb);
            }
            currentEmbeddings = newEmbeddings;
        }
        this.nodeEmbeddings = currentEmbeddings;
        this.graphEmbedding = Array(this.hiddenSize).fill(0);
        for (let i = 0; i < N; i++)
            for (let j = 0; j < this.hiddenSize; j++)
                this.graphEmbedding[j] += this.nodeEmbeddings[i][j];
        for (let j = 0; j < this.hiddenSize; j++)
            this.graphEmbedding[j] /= N;
        this.readoutOutput = this.readoutLayer.forward(this.graphEmbedding, activation);
        const output = this.outputLayer.forward(this.readoutOutput, activations.sigmoid);
        return output;
    }
    predict(graph) { return this.forward(graph);}
}

function convertNeuronsToDenseFormat(layerData) {
    if (!layerData || !layerData.neurons) return null;
    const weights = layerData.neurons.map(n => n.weights || []);
    const biases = layerData.neurons.map(n => n.bias || 0);
    return { weights, biases };
}

let loadedGNN = null, modelConfig = null;

function loadModel() {
    let fileInput = document.getElementById('modelFile');
    let status = document.getElementById('modelStatus');
    if (!fileInput.files.length) { status.textContent = 'No file selected.'; return;}
    const reader = new FileReader();
    reader.onload = function(e){
        try {
            const data = JSON.parse(e.target.result);
            
            // Extract config with fallback support for both snake_case and camelCase
            const featureSize = data.feature_size || data.featureSize || (data.config?.featureSize);
            const hiddenSize = data.hidden_size || data.hiddenSize || (data.config?.hiddenSize);
            const outputSize = data.output_size || data.outputSize || (data.config?.outputSize);
            const numMPLayers = data.num_message_passing_layers || data.numMPLayers || (data.config?.numMPLayers);
            const activation = data.activation || data.activationType || 'relu';
            
            if (!featureSize || !hiddenSize || !outputSize || !numMPLayers) {
                status.textContent = 'Invalid model data: missing configuration';
                return;
            }
            
            modelConfig = { featureSize, hiddenSize, outputSize, numMPLayers };
            
            loadedGNN = new GraphNeuralNetwork(featureSize, hiddenSize, outputSize, numMPLayers);
            loadedGNN.activationType = activation;
            
            // Get layer data - handle both snake_case and camelCase
            const messageLayers = data.message_layers || data.messageLayers || [];
            const updateLayers = data.update_layers || data.updateLayers || [];
            const readoutLayer = data.readout_layer || data.readoutLayer;
            const outputLayer = data.output_layer || data.outputLayer;
            
            // Convert each layer from neuron format to DenseLayer format
            messageLayers.forEach((layer, i) => {
                const converted = convertNeuronsToDenseFormat(layer);
                if (converted && i < loadedGNN.messageLayers.length) {
                    loadedGNN.messageLayers[i].setWeights(converted);
                }
            });
            
            updateLayers.forEach((layer, i) => {
                const converted = convertNeuronsToDenseFormat(layer);
                if (converted && i < loadedGNN.updateLayers.length) {
                    loadedGNN.updateLayers[i].setWeights(converted);
                }
            });
            
            if (readoutLayer) {
                const converted = convertNeuronsToDenseFormat(readoutLayer);
                if (converted) loadedGNN.readoutLayer.setWeights(converted);
            }
            
            if (outputLayer) {
                const converted = convertNeuronsToDenseFormat(outputLayer);
                if (converted) loadedGNN.outputLayer.setWeights(converted);
            }
            
            status.textContent = "Model loaded: "
                +"features/node:"+featureSize
                +" hidden:"+hiddenSize
                +" output:"+outputSize
                +" MP layers:"+numMPLayers;
            
            visualizeGNNArchitecture(loadedGNN, 'networkVisualization');
        } catch (err) {
            status.textContent = "Error loading model: " + err;
        }
    };
    reader.readAsText(fileInput.files[0]);
}

function runInference() {
    let outputDiv = document.getElementById('output');
    if (!loadedGNN || !modelConfig) {
        outputDiv.textContent = "No model loaded.";
        return;
    }
    // Features:
    let featText = document.getElementById('nodeFeatures').value.trim();
    let featRows = featText.split(/\n/).map(row => row.trim()).filter(Boolean);
    let nodeFeatures = featRows.map(row => row.split(',').map(Number));
    if (nodeFeatures.length !== nodeFeatures.filter(f => f.length === modelConfig.featureSize).length) {
        outputDiv.textContent = `Features: every node must have ${modelConfig.featureSize} values.`;
        return;
    }
    if (nodeFeatures.some(arr => arr.some(isNaN))) {
        outputDiv.textContent = "Features must all be numeric.";
        return;
    }
    // Edges:
    let edgeText = document.getElementById('edgeList').value.trim();
    let edgeRows = edgeText.split(/\n/).filter(Boolean);
    let edges = [];
    for (let i = 0; i < edgeRows.length; i++) {
        const parts = edgeRows[i].split(',').map(s=>parseInt(s.trim()));
        if (parts.length !== 2 || parts.some(isNaN)
            || parts[0] < 0 || parts[1] < 0
            || parts[0] >= nodeFeatures.length || parts[1] >= nodeFeatures.length) {
            outputDiv.textContent = `Edge ${i+1} invalid: expected "source,target" in [0,${nodeFeatures.length-1}]`;
            return;
        }
        edges.push(new Edge(parts[0], parts[1]));
    }
    let g = new Graph(nodeFeatures.length);
    g.nodeFeatures = nodeFeatures;
    g.edges = edges;
    g.buildAdjacencyList();
    try {
        const output = loadedGNN.predict(g);
        outputDiv.textContent = "Output: " + JSON.stringify(output, null, 2);
    } catch (err) {
        outputDiv.textContent = "Inference error: " + err;
    }
}

// ==================== GNN ARCHITECTURE VISUALIZATION ====================

function visualizeGNNArchitecture(gnn, containerId) {
    const container = document.getElementById(containerId);
    const section = document.getElementById('networkVizSection');
    if (!container || !section || !gnn) return;
    
    // Show the section
    section.style.display = 'block';
    
    const featureSize = gnn.featureSize;
    const hiddenSize = gnn.hiddenSize;
    const outputSize = gnn.outputSize;
    const numMPLayers = gnn.numMPLayers;
    
    const spacing = 85;
    const padding = 20;
    const legendSpace = 80;
    const totalLayers = 2 + numMPLayers * 2 + 2;
    const totalWidth = totalLayers * spacing + padding * 2 + legendSpace;
    const totalHeight = 200;
    
    const svgContainer = document.createElement('div');
    svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', totalHeight);
    svg.setAttribute('style', 'display: block;');
    
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <linearGradient id="msgGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#4285f4;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#1967d2;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="updGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#34a853;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#188038;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="readGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#ea4335;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#c5221f;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="outGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#fbbc04;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#f57d00;stop-opacity:1" />
        </linearGradient>
    `;
    svg.appendChild(defs);
    
    let xPos = padding + legendSpace;
    const cy = totalHeight / 2;
    
    function drawBox(x, y, w, h, fill, stroke, texts) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', x - w/2);
        box.setAttribute('y', y - h/2);
        box.setAttribute('width', w);
        box.setAttribute('height', h);
        box.setAttribute('fill', fill);
        box.setAttribute('stroke', stroke);
        box.setAttribute('stroke-width', 1.5);
        box.setAttribute('rx', 3);
        g.appendChild(box);
        
        texts.forEach((t, i) => {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y - 18 + i * 14);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', t.size || '9');
            if (t.bold) text.setAttribute('font-weight', 'bold');
            text.setAttribute('fill', t.color || 'white');
            text.textContent = t.text;
            g.appendChild(text);
        });
        svg.appendChild(g);
    }
    
    // Input layer
    drawBox(xPos, cy, 50, 70, '#e8f5e9', '#2e7d32', [
        { text: 'Input', size: '10', bold: true, color: '#1b5e20' },
        { text: `${featureSize}f`, size: '9', color: '#1b5e20' }
    ]);
    xPos += spacing;
    
    // Message passing layers
    for (let i = 0; i < numMPLayers; i++) {
        const inputSize = i === 0 ? featureSize * 2 : hiddenSize * 2;
        drawBox(xPos, cy, 56, 70, 'url(#msgGrad)', '#1967d2', [
            { text: `Msg${i+1}`, size: '9', bold: true },
            { text: `${inputSize}→${hiddenSize}`, size: '8' }
        ]);
        xPos += spacing;
        
        drawBox(xPos, cy, 56, 70, 'url(#updGrad)', '#188038', [
            { text: `Upd${i+1}`, size: '9', bold: true },
            { text: `${hiddenSize*2}→${hiddenSize}`, size: '8' }
        ]);
        xPos += spacing;
    }
    
    // Readout
    drawBox(xPos, cy, 50, 70, 'url(#readGrad)', '#c5221f', [
        { text: 'Readout', size: '9', bold: true },
        { text: `${hiddenSize}`, size: '8' }
    ]);
    xPos += spacing;
    
    // Output
    drawBox(xPos, cy, 56, 70, 'url(#outGrad)', '#f57d00', [
        { text: 'Output', size: '10', bold: true },
        { text: `${outputSize}c`, size: '8' }
    ]);
    
    // Legend
    const legendItems = [
        { label: 'Msg', color: 'url(#msgGrad)' },
        { label: 'Upd', color: 'url(#updGrad)' },
        { label: 'Read', color: 'url(#readGrad)' },
        { label: 'Out', color: 'url(#outGrad)' }
    ];
    let ly = cy - 30;
    legendItems.forEach(item => {
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', padding + 5);
        box.setAttribute('y', ly);
        box.setAttribute('width', 10);
        box.setAttribute('height', 10);
        box.setAttribute('fill', item.color);
        box.setAttribute('stroke', '#666');
        box.setAttribute('stroke-width', 0.5);
        box.setAttribute('rx', 2);
        svg.appendChild(box);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', padding + 19);
        text.setAttribute('y', ly + 8);
        text.setAttribute('font-size', '9');
        text.setAttribute('fill', '#333');
        text.textContent = item.label;
        svg.appendChild(text);
        ly += 13;
    });
    
    svgContainer.innerHTML = '';
    svgContainer.appendChild(svg);
    container.innerHTML = '';
    container.appendChild(svgContainer);
}

</script>
</body>
</html>
