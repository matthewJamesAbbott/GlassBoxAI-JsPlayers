<!--
MIT License

Copyright (c) 2025 Matthew Abbott

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions: 

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RNN Player</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2rem; background: #fafafa; }
        .section { margin-bottom: 2rem; background: #fff; padding: 1rem; border-radius: 8px; border-bottom: 1px solid #ccc; }
        label { display: block; margin-top: 0.5rem; }
        input, select, textarea, button { margin: 0.5rem 0; }
        textarea { width: 100%; height: 5rem; font-family: monospace; resize: vertical; }
        .results { background: #f5f5f5; padding: 1rem; border-radius: 5px; }
        button { padding: 8px 16px; cursor: pointer; background: #5a5a5a; color: white; border: none; border-radius: 0; }
        button:hover { background: #4a4a4a; }
        button:active { background: #3a3a3a; }
        button:disabled { background: #ccc; cursor: not-allowed; }
    </style>
</head>
<body>
<script>
function visualizeRNNArchitecture(rnn, containerId) {
    if (!rnn) return;
    const container = document.getElementById(containerId);
    if (!container) return;

    const spacing = 85;
    const padding = 20;
    const legendSpace = 80;
    const numHiddenLayers = rnn.hiddenSizes?.length || rnn.cells?.length || 0;
    const totalLayers = 2 + numHiddenLayers;
    const totalWidth = totalLayers * spacing + padding * 2 + legendSpace;
    const totalHeight = 200;

    const svgContainer = document.createElement('div');
    svgContainer.setAttribute('style', 'overflow-x: auto; overflow-y: hidden; border: 1px solid #ccc; background: #fafafa; border-radius: 4px; margin: 1rem 0; height: 220px;');

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', totalHeight);
    svg.setAttribute('style', 'display: block;');

    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
        <linearGradient id="inputGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#4caf50;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#2e7d32;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="rnnGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#9c27b0;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#6a1b9a;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="lstmGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#2196f3;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#1565c0;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="gruGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#ff9800;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#ef6c00;stop-opacity:1" />
        </linearGradient>
        <linearGradient id="outGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#f44336;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#c62828;stop-opacity:1" />
        </linearGradient>
    `;
    svg.appendChild(defs);

    let xPos = padding + legendSpace;
    const cy = totalHeight / 2;
    const cellType = (rnn.cellType || 'lstm').toLowerCase();

    drawRNNInputLayer(svg, xPos, cy, rnn.inputSize || 4);
    xPos += spacing;

    const hiddenSizes = rnn.hiddenSizes || [16];
    for (let i = 0; i < hiddenSizes.length; i++) {
        drawRNNCellLayer(svg, xPos, cy, cellType, hiddenSizes[i], i + 1);
        xPos += spacing;
    }

    drawRNNOutputLayer(svg, xPos, cy, rnn.outputSize || 3, rnn.outputActivation || 'linear');
    drawRNNLegend(svg, padding + 5, cy - 40, cellType);

    svgContainer.innerHTML = '';
    svgContainer.appendChild(svg);
    container.innerHTML = '';
    container.appendChild(svgContainer);
}

function drawRNNInputLayer(svg, x, cy, size) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 25); box.setAttribute('y', cy - 35);
    box.setAttribute('width', 50); box.setAttribute('height', 70);
    box.setAttribute('fill', 'url(#inputGrad)'); box.setAttribute('stroke', '#1b5e20');
    box.setAttribute('stroke-width', 1.5); box.setAttribute('rx', 3);
    g.appendChild(box);

    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x); text1.setAttribute('y', cy - 12);
    text1.setAttribute('text-anchor', 'middle'); text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold'); text1.setAttribute('fill', 'white');
    text1.textContent = 'Input';
    g.appendChild(text1);

    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x); text2.setAttribute('y', cy + 8);
    text2.setAttribute('text-anchor', 'middle'); text2.setAttribute('font-size', '9');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${size}`;
    g.appendChild(text2);

    svg.appendChild(g);
}

function drawRNNCellLayer(svg, x, cy, cellType, hiddenSize, layerNum) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    let gradId = 'lstmGrad', strokeColor = '#1565c0', label = 'LSTM';
    if (cellType === 'gru') { gradId = 'gruGrad'; strokeColor = '#ef6c00'; label = 'GRU'; }
    else if (cellType === 'rnn' || cellType === 'simplernn') { gradId = 'rnnGrad'; strokeColor = '#6a1b9a'; label = 'RNN'; }

    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 28); box.setAttribute('y', cy - 35);
    box.setAttribute('width', 56); box.setAttribute('height', 70);
    box.setAttribute('fill', `url(#${gradId})`); box.setAttribute('stroke', strokeColor);
    box.setAttribute('stroke-width', 1.5); box.setAttribute('rx', 3);
    g.appendChild(box);

    const recur = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    recur.setAttribute('d', `M${x-10},${cy-35} Q${x-10},${cy-50} ${x},${cy-50} Q${x+10},${cy-50} ${x+10},${cy-35}`);
    recur.setAttribute('fill', 'none'); recur.setAttribute('stroke', 'white');
    recur.setAttribute('stroke-width', 2);
    g.appendChild(recur);

    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x); text1.setAttribute('y', cy - 5);
    text1.setAttribute('text-anchor', 'middle'); text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold'); text1.setAttribute('fill', 'white');
    text1.textContent = `${label}${layerNum}`;
    g.appendChild(text1);

    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x); text2.setAttribute('y', cy + 12);
    text2.setAttribute('text-anchor', 'middle'); text2.setAttribute('font-size', '9');
    text2.setAttribute('fill', 'white');
    text2.textContent = `h=${hiddenSize}`;
    g.appendChild(text2);

    svg.appendChild(g);
}

function drawRNNOutputLayer(svg, x, cy, size, activation) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    box.setAttribute('x', x - 28); box.setAttribute('y', cy - 35);
    box.setAttribute('width', 56); box.setAttribute('height', 70);
    box.setAttribute('fill', 'url(#outGrad)'); box.setAttribute('stroke', '#c62828');
    box.setAttribute('stroke-width', 1.5); box.setAttribute('rx', 3);
    g.appendChild(box);

    const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text1.setAttribute('x', x); text1.setAttribute('y', cy - 12);
    text1.setAttribute('text-anchor', 'middle'); text1.setAttribute('font-size', '10');
    text1.setAttribute('font-weight', 'bold'); text1.setAttribute('fill', 'white');
    text1.textContent = 'Output';
    g.appendChild(text1);

    const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text2.setAttribute('x', x); text2.setAttribute('y', cy + 5);
    text2.setAttribute('text-anchor', 'middle'); text2.setAttribute('font-size', '9');
    text2.setAttribute('fill', 'white');
    text2.textContent = `${size}`;
    g.appendChild(text2);

    const text3 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text3.setAttribute('x', x); text3.setAttribute('y', cy + 18);
    text3.setAttribute('text-anchor', 'middle'); text3.setAttribute('font-size', '8');
    text3.setAttribute('fill', 'white');
    text3.textContent = activation;
    g.appendChild(text3);

    svg.appendChild(g);
}

function drawRNNLegend(svg, x, y, cellType) {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    let cellColor = 'url(#lstmGrad)', cellLabel = 'LSTM';
    if (cellType === 'gru') { cellColor = 'url(#gruGrad)'; cellLabel = 'GRU'; }
    else if (cellType === 'rnn' || cellType === 'simplernn') { cellColor = 'url(#rnnGrad)'; cellLabel = 'RNN'; }

    const items = [
        { label: 'Input', color: 'url(#inputGrad)' },
        { label: cellLabel, color: cellColor },
        { label: 'Output', color: 'url(#outGrad)' }
    ];

    let yOffset = y;
    items.forEach(item => {
        const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        box.setAttribute('x', x); box.setAttribute('y', yOffset);
        box.setAttribute('width', 10); box.setAttribute('height', 10);
        box.setAttribute('fill', item.color); box.setAttribute('stroke', '#666');
        box.setAttribute('stroke-width', 0.5); box.setAttribute('rx', 2);
        g.appendChild(box);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', x + 14); text.setAttribute('y', yOffset + 8);
        text.setAttribute('font-size', '9'); text.setAttribute('fill', '#333');
        text.textContent = item.label;
        g.appendChild(text);

        yOffset += 18;
    });

    svg.appendChild(g);
}
</script>
    <h1>RNN Player</h1>

    <div class="section">
        <h2>Load Trained Model</h2>
        <input type="file" id="modelFile" accept=".json">
        <button onclick="loadModel()">Load Model</button>
        <span id="modelStatus"></span>
        <div id="networkViz"></div>
    </div>

    <div class="section">
        <h2>Input Sequence</h2>
        <label>Each row: comma separated values (e.g. sequence of timesteps):</label>
        <textarea id="predictSeq" rows="3"></textarea>
    </div>

    <div class="section">
        <button onclick="predictSequence()">Predict Sequence</button>
    </div>

    <div class="section">
        <h2>Output</h2>
        <div id="predictOutput" class="results"></div>
    </div>

<script>
const Activations = {
    sigmoid: { fn: x=>1/(1+Math.exp(-Math.max(-500,Math.min(500,x)))) },
    tanh: { fn: x=>Math.tanh(x) },
    relu: { fn: x=>Math.max(0,x) },
    linear: { fn: x=>x },
    softmax: { 
        fn: (x, arr) => {
            const maxVal = Math.max(...arr);
            const exps = arr.map(v => Math.exp(v - maxVal));
            const sum = exps.reduce((a,b)=>a+b,0);
            return exps[arr.indexOf(x)] / sum;
        }
    }
};

function applySoftmax(arr) {
    const maxVal = Math.max(...arr);
    const exps = arr.map(v => Math.exp(v - maxVal));
    const sum = exps.reduce((a,b)=>a+b,0);
    return exps.map(e=>e/sum);
}

// ----- Minimal cell classes needed for inference -----
class SimpleRNNCell {
    constructor(inputSize, hiddenSize, activation) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.activation = activation;
        this.Wih = []; this.Whh = []; this.bh = [];
    }
    forward(input, prevH) {
        const act = Activations[this.activation];
        const h = new Array(this.hiddenSize);
        for (let i=0;i<this.hiddenSize;i++){
            let sum = this.bh[i];
            for (let j=0;j<this.inputSize;j++) sum += this.Wih[i][j] * input[j];
            for (let j=0;j<this.hiddenSize;j++) sum += this.Whh[i][j] * prevH[j];
            h[i] = act.fn(sum);
        }
        return { h };
    }
    static fromJSON(json){
        const cell = new SimpleRNNCell(json.inputSize, json.hiddenSize, json.activation);
        cell.Wih = json.Wih; cell.Whh = json.Whh; cell.bh = json.bh;
        return cell;
    }
}

class LSTMCell {
    constructor(inputSize, hiddenSize, activation) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.activation = activation;
        this.Wf=[];this.Wi=[];this.Wc=[];this.Wo=[];
        this.bf=[];this.bi=[];this.bc=[];this.bo=[];
    }
    forward(input, prevH, prevC) {
        prevC = prevC || new Array(this.hiddenSize).fill(0);
        const concat = [...input, ...prevH];
        const sigmoid = Activations.sigmoid.fn;
        const tanhFn = Activations.tanh.fn;
        const f=[],i=[],cTilde=[],o=[],c=[],h=[];
        for (let k=0; k<this.hiddenSize;k++){
            let sumF=this.bf[k], sumI=this.bi[k], sumC=this.bc[k], sumO=this.bo[k];
            for (let j=0;j<concat.length;j++){
                sumF+=this.Wf[k][j]*concat[j];
                sumI+=this.Wi[k][j]*concat[j];
                sumC+=this.Wc[k][j]*concat[j];
                sumO+=this.Wo[k][j]*concat[j];
            }
            f[k]=sigmoid(sumF); i[k]=sigmoid(sumI); cTilde[k]=tanhFn(sumC); o[k]=sigmoid(sumO);
            c[k]=f[k]*prevC[k]+i[k]*cTilde[k]; h[k]=o[k]*tanhFn(c[k]);
        }
        return { h, c };
    }
    static fromJSON(json){
        const cell = new LSTMCell(json.inputSize, json.hiddenSize, json.activation);
        cell.Wf=json.Wf;cell.Wi=json.Wi;cell.Wc=json.Wc;cell.Wo=json.Wo;
        cell.bf=json.bf;cell.bi=json.bi;cell.bc=json.bc;cell.bo=json.bo;
        return cell;
    }
}

class GRUCell {
    constructor(inputSize, hiddenSize, activation){
        this.inputSize=inputSize;this.hiddenSize=hiddenSize;this.activation=activation;
        this.Wz=[];this.Wr=[];this.Wh=[];this.bz=[];this.br=[];this.bh=[];
    }
    forward(input, prevH) {
        const concat = [...input, ...prevH];
        const sigmoid = Activations.sigmoid.fn, tanhFn = Activations.tanh.fn;
        const z = [], r = [];
        for (let k=0; k<this.hiddenSize; k++){
            let sumZ = this.bz[k], sumR = this.br[k];
            for (let j=0;j<concat.length;j++){
                sumZ+=this.Wz[k][j]*concat[j]; sumR+=this.Wr[k][j]*concat[j];
            }
            z[k]=sigmoid(sumZ); r[k]=sigmoid(sumR);
        }
        const rh=prevH.map((h,i)=>r[i]*h), concatR=[...input,...rh], hTilde=[];
        for (let k=0;k<this.hiddenSize;k++){
            let sumH=this.bh[k];
            for (let j=0;j<concatR.length;j++) sumH+=this.Wh[k][j]*concatR[j];
            hTilde[k]=tanhFn(sumH);
        }
        const h = [];
        for(let k=0;k<this.hiddenSize;k++)
            h[k] = (1-z[k])*prevH[k] + z[k]*hTilde[k];
        return { h };
    }
    static fromJSON(json){
        const cell = new GRUCell(json.inputSize, json.hiddenSize, json.activation);
        cell.Wz=json.Wz;cell.Wr=json.Wr;cell.Wh=json.Wh;
        cell.bz=json.bz;cell.br=json.br;cell.bh=json.bh;
        return cell;
    }
}

class OutputLayer {
    constructor(inputSize, outputSize, activation){
        this.inputSize=inputSize;this.outputSize=outputSize;this.activation=activation;
        this.W=[];this.b=[];
    }
    forward(input){
        const pre=new Array(this.outputSize);
        for(let i=0;i<this.outputSize;i++){
            let sum=this.b[i];
            for(let j=0;j<this.inputSize;j++) sum+=this.W[i][j]*input[j];
            pre[i]=sum;
        }
        let out;
        if(this.activation==="softmax") out = applySoftmax(pre);
        else {
            const act = Activations[this.activation] || Activations.linear;
            out = pre.map(v=>act.fn(v));
        }
        return out;
    }
    static fromJSON(json){
        const layer = new OutputLayer(json.inputSize, json.outputSize, json.activation);
        layer.W = json.W; layer.b = json.b;
        return layer;
    }
}

class AdvancedRNN {
    constructor(config){
        this.inputSize = config.inputSize;
        this.outputSize = config.outputSize;
        this.hiddenSizes = config.hiddenSizes;
        this.cellType = config.cellType || 'lstm';
        this.activation = config.activation || 'tanh';
        this.outputActivation = config.outputActivation || 'linear';
        this.cells = [];
        let prevSize = this.inputSize;
        for (const hs of this.hiddenSizes){
            let cell;
            if(this.cellType==='lstm') cell = new LSTMCell(prevSize, hs, this.activation);
            else if(this.cellType==='gru') cell = new GRUCell(prevSize, hs, this.activation);
            else cell = new SimpleRNNCell(prevSize, hs, this.activation);
            this.cells.push(cell);
            prevSize = hs;
        }
        this.outputLayer = new OutputLayer(prevSize, this.outputSize, this.outputActivation);
    }
    initHiddenState(){
        return this.cells.map(cell=>({
            h: new Array(cell.hiddenSize).fill(0),
            c: new Array(cell.hiddenSize).fill(0)
        }));
    }
    forwardStep(input, states){
        let x = input, newStates=[];
        for(let i=0;i<this.cells.length;i++){
            const cell = this.cells[i];
            if(cell instanceof LSTMCell){
                const vals = cell.forward(x, states[i].h, states[i].c);
                newStates.push({ h: vals.h, c: vals.c }); x = vals.h;
            }else if(cell instanceof GRUCell){
                const vals = cell.forward(x, states[i].h); 
                newStates.push({ h: vals.h, c: states[i].c }); x = vals.h;
            }else{
                const vals = cell.forward(x, states[i].h); 
                newStates.push({ h: vals.h, c: states[i].c }); x = vals.h;
            }
        }
        const out = this.outputLayer.forward(x);
        return { output: out, states: newStates };
    }
    predict(inputs){
        let states = this.initHiddenState(), outputs=[];
        for(const input of inputs){
            const result = this.forwardStep(input, states);
            outputs.push(result.output);
            states=result.states;
        }
        return outputs;
    }
    static fromJSON(jsonStr){
        const obj = typeof jsonStr === "string" ? JSON.parse(jsonStr):jsonStr;
        const config = {
            inputSize: obj.input_size ?? obj.inputSize,
            outputSize: obj.output_size ?? obj.outputSize,
            hiddenSizes: obj.hidden_sizes ?? obj.hiddenSizes,
            cellType: obj.cell_type ?? obj.cellType,
            activation: obj.activation,
            outputActivation: obj.output_activation ?? obj.outputActivation
        };
        if (config.cellType === 'simplernn') config.cellType = 'rnn';
        const rnn = new AdvancedRNN(config);
        
        if (obj.cells && obj.cells.length > 0) {
            for (let i = 0; i < obj.cells.length; i++) {
                const cellData = obj.cells[i];
                const cell = rnn.cells[i];
                if (cell instanceof LSTMCell) {
                    cell.Wf = cellData.Wf; cell.Wi = cellData.Wi; cell.Wc = cellData.Wc; cell.Wo = cellData.Wo;
                    cell.bf = cellData.Bf ?? cellData.bf; cell.bi = cellData.Bi ?? cellData.bi;
                    cell.bc = cellData.Bc ?? cellData.bc; cell.bo = cellData.Bo ?? cellData.bo;
                } else if (cell instanceof GRUCell) {
                    cell.Wz = cellData.Wz; cell.Wr = cellData.Wr; cell.Wh = cellData.Wh;
                    cell.bz = cellData.Bz ?? cellData.bz; cell.br = cellData.Br ?? cellData.br; cell.bh = cellData.Bh ?? cellData.bh;
                } else {
                    cell.Wih = cellData.Wih; cell.Whh = cellData.Whh; cell.bh = cellData.bh;
                }
            }
        }
        const outLayer = obj.output_layer ?? obj.outputLayer;
        if (outLayer) {
            rnn.outputLayer.W = outLayer.W;
            rnn.outputLayer.b = outLayer.B ?? outLayer.b;
        }
        return rnn;
    }
}

let rnnModel = null, modelConfig = null;

function loadModel(){
    let fileInput = document.getElementById('modelFile');
    let status = document.getElementById('modelStatus');
    if(!fileInput.files.length){status.textContent="No file selected.";return;}
    const reader = new FileReader();
    reader.onload = function(e){
        try{
            rnnModel = AdvancedRNN.fromJSON(e.target.result);
            const obj = JSON.parse(e.target.result);
            modelConfig = {
                inputSize: obj.input_size ?? obj.inputSize,
                outputSize: obj.output_size ?? obj.outputSize,
                hiddenSizes: obj.hidden_sizes ?? obj.hiddenSizes,
                cellType: obj.cell_type ?? obj.cellType,
                outputActivation: obj.output_activation ?? obj.outputActivation
            };
            if (modelConfig.cellType === 'simplernn') modelConfig.cellType = 'rnn';
            status.textContent =
                "Model loaded: Input "+modelConfig.inputSize+" Hidden ["+modelConfig.hiddenSizes+"] Out "+modelConfig.outputSize
                +" Cell "+modelConfig.cellType.toUpperCase()+" OutputActivation "+modelConfig.outputActivation;
            visualizeRNNArchitecture(modelConfig, 'networkViz');
        }catch(err){
            status.textContent = "Error loading model: "+err;
        }
    };
    reader.readAsText(fileInput.files[0]);
}

function predictSequence(){
    let outDiv = document.getElementById('predictOutput');
    if(!rnnModel||!modelConfig){
        outDiv.textContent="No model loaded.";return;
    }
    const txt = document.getElementById("predictSeq").value.trim();
    if(!txt){outDiv.textContent="Enter an input sequence.";return;}
    let rows = txt.split(/[\n;]/).map(row=>row.trim()).filter(Boolean);
    let seq = rows.map(row=>row.split(",").map(Number));
    if(seq.length === 0 || seq.some(s => s.length !== modelConfig.inputSize)){
        outDiv.textContent = "Input should have "+modelConfig.inputSize+" values per row.";
        return;
    }
    if(seq.some(arr=> arr.some(isNaN))){
        outDiv.textContent="Input must be all valid numeric values.";return;
    }
    try{
        const output = rnnModel.predict(seq);
        outDiv.textContent = "Output sequence:\n" + JSON.stringify(output, null, 2);
    }catch(err){
        outDiv.textContent = "Inference error: "+err;
    }
}
</script>
</body>
</html>
